import std/[strformat, options, tables]
import ./log
when defined(butlerThreading):
  import threading/channels
  import std/isolation
  
when defined(butlerThreading):
  proc createChannel[Msg](capacity: int): ptr Chan[Msg] =
    let result = createShared(Chan[Msg])
    result[] = newChan[Msg](capacity)
    result

else:
  proc createChannel[Msg](capacity: int): ptr Channel[Msg] =
    let result = createShared(Channel[Msg])
    result[] = Channel[Msg]()
    result[].open()
    result

type ChannelHubError* = object of KeyError

##[
Defines utilities for interacting with a ChannelHub.
Further utilities may be generated by `codegen`.

A ChannelHub is a table of **all** Channels to *all* thread-servers in an application.
It contains one Channel per registered Thread through which one specific "Message"-object variant can be sent.
The channel for a given Message-object-variant is stored with (and can thus be retrieved with) data inferred from the object-variant.
]##

type ChannelHub* = object
  channels*: Table[pointer, pointer]

proc addChannel*[Msg](hub: var ChannelHub, t: typedesc[Msg], capacity: int) =
  ## Instantiates and opens a `Channel` to `hub` specifically for type `Msg`.
  ## This associates it with `Msg`. 
  let key: pointer = default(Msg).getTypeInfo()
  hub.channels[key] = createChannel[Msg](capacity)
  
  let keyInt = cast[uint64](key)
  let channelInt = cast[uint64](hub.channels[key])
  let typ = $Msg
  notice "Added Channel", typ, keyInt, channelInt 

when defined(butlerThreading):
  proc getChannel*[Msg](hub: ChannelHub, t: typedesc[Msg]): Chan[Msg] {.raises: [ChannelHubError].} =
    ## Fetches the `Channel` associated with `Msg` from `hub`.
    let key: pointer = default(t).getTypeInfo()
    var channelPtr: pointer = nil
    try:
      channelPtr = hub.channels[key]
    except KeyError as e:
      const msgName = $Msg
      raise (ref ChannelHubError)(
        msg: "There is no Channel for the message type '" & msgName & "'.",
        parent: e
      )
      
    return cast[ptr Chan[Msg]](channelPtr)[]
    
else:
  proc getChannel*[Msg](hub: ChannelHub, t: typedesc[Msg]): var Channel[Msg] {.raises: [ChannelHubError].} =
    ## Fetches the `Channel` associated with `Msg` from `hub`.
    let key: pointer = default(t).getTypeInfo()
    var channelPtr: pointer = nil
    try:
      channelPtr = hub.channels[key]
    except KeyError as e:      
      const msgName = $Msg
      raise (ref ChannelHubError)(
        msg: "There is no Channel for the message type '" & msgName & "'.",
        parent: e
      )
    return cast[ptr Channel[Msg]](channelPtr)[]

proc debugSendLog[Msg](msg: Msg, hub: ChannelHub) =
  debug "send: Thread => Channel", msg

const SEND_PROC_NAME* = "sendMsgToChannel"
proc sendMsgToChannel*[Msg](hub: ChannelHub, msg: sink Msg): bool {.raises: [ChannelHubError].} =
  ## Sends a message through the Channel associated with `Msg`.
  ## This is non-blocking.
  ## Returns `bool` stating if sending was successful.
  debugSendLog(msg, hub)
  when defined(butlerThreading):
    let msg = msg.unsafeIsolate()
    
  try:
    result = hub.getChannel(Msg).trySend(msg) 
    if not result:
      debug "Failed to send message" 
  except Exception as e:
    raise (ref ChannelHubError)(
      msg: "Error while sending message",
      parent: e
    )
    
proc debugReadLog[Msg](msg: Msg, hub: ChannelHub) {.raises: [].} =
  debug "read: Thread <= Channel", msg

proc readMsg*[Msg](hub: ChannelHub, resp: typedesc[Msg]): Option[Msg] =
  ## Reads message from the Channel associated with `Msg`.
  ## This is non-blocking.
  let response: tuple[dataAvailable: bool, msg: Msg] = 
    when defined(butlerThreading):
      var msg: Msg
      let hasMsg = hub.getChannel(Msg).tryRecv(msg)
      (hasMsg, msg)
    else:
      hub.getChannel(Msg).tryRecv()

  result = if response.dataAvailable:
      debugReadLog(response.msg, hub)
      some(response.msg)
    else:
      none(Msg)