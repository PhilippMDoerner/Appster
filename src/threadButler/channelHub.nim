import std/[strformat, options, tables]
import ./log
when defined(butlerThreading):
  import threading/channels
  
when defined(butlerThreading):
  template createChannel[Msg](capacity: int): Chan[Msg] =
    newChan[Msg](capacity)
else:
  template createChannel[Msg](capacity: int): Channel[Msg] =
    var result = Channel[Msg]()
    result.open()
    result

type ChannelHubError* = object of KeyError

##[
Defines utilities for interacting with a ChannelHub.
Further utilities may be generated by `codegen`.

A ChannelHub is a table of **all** Channels to *all* thread-servers in an application.
It contains one Channel per registered Thread through which one specific "Message"-object variant can be sent.
The channel for a given Message-object-variant is stored with (and can thus be retrieved with) data inferred from the object-variant.
]##

type ChannelHub* = object
  channels*: Table[pointer, pointer]

proc addChannel*[Msg](hub: var ChannelHub, t: typedesc[Msg], capacity: int) =
  ## Instantiates and opens a `Channel` to `hub` specifically for type `Msg`.
  ## This associates it with `Msg`. 
  let key: pointer = default(Msg).getTypeInfo()
  var channel {.global.} = createChannel[Msg](capacity)
  hub.channels[key] = channel.addr
  notice fmt"Added: {$t} - key: {cast[uint64](key)} | value: {cast[uint64](channel.addr)}"

when defined(butlerThreading):
  proc getChannel*[Msg](hub: ChannelHub, t: typedesc[Msg]): Chan[Msg] {.raises: [ChannelHubError].} =
    ## Fetches the `Channel` associated with `Msg` from `hub`.
    let key: pointer = default(t).getTypeInfo()
    var channelPtr: pointer = nil
    try:
      channelPtr = hub.channels[key]
    except KeyError as e:
      const msgName = $Msg
      raise (ref ChannelHubError)(
        msg: "There is no Channel for the message type '" & msgName & "'.",
        parent: e
      )
      
    return cast[ptr Chan[Msg]](channelPtr)[]
    
else:
  proc getChannel*[Msg](hub: ChannelHub, t: typedesc[Msg]): var Channel[Msg] {.raises: [ChannelHubError].} =
    ## Fetches the `Channel` associated with `Msg` from `hub`.
    let key: pointer = default(t).getTypeInfo()
    var channelPtr: pointer = nil
    try:
      channelPtr = hub.channels[key]
    except KeyError as e:      
      const msgName = $Msg
      raise (ref ChannelHubError)(
        msg: "There is no Channel for the message type '" & msgName & "'.",
        parent: e
      )
    return cast[ptr Channel[Msg]](channelPtr)[]

proc debugSendLog[Msg](msg: Msg, hub: ChannelHub, success: bool) =
  let msg = "Thread '" & $getThreadId() & "' => " & $msg
  if success:
    debug "send: " & $msg
  else:
    let queueLength = hub.getChannel(Msg).peek()
    error "failed to send ('" & $queueLength & "' msgs in queue): " & $msg

const SEND_PROC_NAME* = "sendMsgToChannel"
proc sendMsgToChannel*[Msg](hub: ChannelHub, msg: sink Msg): bool {.raises: [ChannelHubError].} =
  ## Sends a message through the Channel associated with `Msg`.
  ## This is non-blocking.
  ## Returns `bool` stating if sending was successful.
  try:
    result = hub.getChannel(Msg).trySend(msg)  
  except Exception as e:
    raise (ref ChannelHubError)(
      msg: "Error while sending message",
      parent: e
    )
    
  debugSendLog(msg, hub, result)

proc debugReadLog[Msg](msg: Msg, hub: ChannelHub) {.raises: [].} =
  debug fmt"read: Thread '" & $getThreadId() & "' <= " & msg.repr

proc readMsg*[Msg](hub: ChannelHub, resp: typedesc[Msg]): Option[Msg] =
  ## Reads message from the Channel associated with `Msg`.
  ## This is non-blocking.
  let response: tuple[dataAvailable: bool, msg: Msg] = 
    when defined(butlerThreading):
      var msg: Msg
      let hasMsg = hub.getChannel(Msg).tryRecv(msg)
      (hasMsg, msg)
    else:
      hub.getChannel(Msg).tryRecv()

  result = if response.dataAvailable:
      debugReadLog(response.msg, hub)
      some(response.msg)
    else:
      none(Msg)